<!DOCTYPE html>
<html>
<head>
<title>Lithuanian tree cake (Å akotis)</title>
<meta charset="UTF-8">
<link rel="canonical" href="http://foldoc.org/pub/js/three.html">
</head>
<body style="overflow: hidden">
<script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
<script>
"use strict";
// https://www.youtube.com/watch?v=jS26QKMVouU
const pi = Math.PI;

const spitLength = 10;
const spitRadius = spitLength / 10;
const spitSpeed = -0.1; // -ve => bottom towards viewer

const dripRadius = 0.15 * spitRadius;
let dripMeshes;
let dripsFalling = [];
let dripsRotating = [];
let dripsFlying = [];
const dripPos = new THREE.Vector3;
const dripColours = [0xD05000, 0xD45800, 0xD86000, 0xDC6800, 0xE07000];

let camera, renderer, scene, spit;
let theta = 0;

function init() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  document.body.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x220000);
  addCamera();
  addLight();
  addSpit();

  const geometry = new THREE.SphereGeometry(dripRadius);
  dripMeshes = dripColours.map(color => new THREE.Mesh(geometry, new THREE.MeshBasicMaterial( { color } )));

  window.addEventListener('resize', restart);
  restart();
  setInterval(animate, 20);
}

function restart() {
  const { innerWidth, innerHeight } = window;
  renderer.setSize(innerWidth-17, innerHeight-15);
  renderer.setPixelRatio(window.devicePixelRatio);
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
}

// https://threejs.org/docs/#api/en/cameras/PerspectiveCamera

function addCamera() {
  camera = new THREE.PerspectiveCamera(70, 1, 0.1, 100);
  camera.position.set(-0.4 * spitLength, 0.1 * spitLength, 0.7 * spitLength); // +ve z is toward viewer
  camera.lookAt(0.3 * camera.position.x, 0, 0);
}

// https://threejs.org/docs/#api/en/lights/PointLight

function addLight() {
  const light = new THREE.PointLight(0xFFFFFF, 2);
  light.position.set(-spitLength, 10, 10);
  scene.add(light);
}

// Create the spit along the x axis, centered on the origin

// https://threejs.org/docs/#api/en/materials/MeshLambertMaterial

function addSpit() {
  const geometry = new THREE.CylinderGeometry(spitRadius, spitRadius, spitLength, 6);
  geometry.rotateZ(0.5*pi); // Rotate about the origin from along the y (vertical) axis to x (horizontal)
  const material = new THREE.MeshLambertMaterial({ color: dripColours[0] });
  spit = new THREE.Mesh(geometry, material);
  scene.add(spit);
}

function animate() {
  spit.rotation.x += spitSpeed;
  addDrip();
  dripsFalling = dripsFalling.filter(falling);
  dripsRotating = dripsRotating.filter(rotating);
  dripsFlying = dripsFlying.filter(flying);
  renderer.render(scene, camera);
}

function addDrip() {
  const drip = any(dripMeshes).clone();
  drip.position.set(randomAlongSpit(), 6, 0);
  scene.add(drip);
  dripsFalling.push(drip);
}

// Lower the drip and return true if it hasn't hit
// anything, else stick it to the spit and return false

function falling(drip) {
  drip.position.y -= 0.1;
  let target;
  if (!(hitSpit(drip) || (target = touchingOtherDrip(drip)))) return true;
  // Position drip relative to spit's current rotation
  spit.add(drip);
  const r = drip.position.y;
  const a = spit.rotation.x;
  if (target) drip.position.x = target.position.x;
  drip.position.y = r*Math.cos(a);
  drip.position.z = -r*Math.sin(a);
  dripsRotating.push(drip);
  return false;
}

// Has the drip hit the spit?

const dripHitSpitY = spitRadius + 0.5*dripRadius;

function hitSpit(drip) {
  return drip.position.y < dripHitSpitY;
}

// Has drip hit a rotating drip?

function touchingOtherDrip(drip) {
  drip.getWorldPosition(dripPos);
  return dripsRotating.find(drop => drop != drip && dripsTouch(dripPos, drop));
}

// Have two drips collided?

const dropPos = new THREE.Vector3;
const dripsTouchDistanceSquared = 2 * dripRadius**2;

function dripsTouch(dripPos, drop) {
  drop.getWorldPosition(dropPos);
  return dripPos.distanceToSquared(dropPos) < dripsTouchDistanceSquared;
}

function rotating(drip) {
  if (Math.random() > 0.005) return true;
  drip.getWorldPosition(dripPos);
  if (Math.abs(dripPos.y + spitRadius) + Math.abs(dripPos.z) > 0.1) return true;
  scene.add(drip);
  dripsFlying.push(drip);
  return false;
}

function flying(drip) {
  drip.position.z += 0.1;
  if ((drip.position.y -= 0.2) > -5*spitRadius) return true;
  scene.remove(drip);
  return false;
}

function randomAlongSpit() { return -0.5*spitLength + spitLength * Math.random() }

function any(array) { return array[Math.floor(array.length * Math.random())] }

function rand(min, max) { return Math.floor(min + (max-min+1) * Math.random()) }

init();
</script>
</body>
</html>
