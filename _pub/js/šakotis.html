<!DOCTYPE html>
<html>
<head>
<title>Lithuanian tree cake (Å akotis)</title>
<meta charset="UTF-8">
<link rel="canonical" href="http://foldoc.org/pub/js/three.html">
</head>
<body style="overflow: hidden">
<script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
<script>
"use strict";
const pi = Math.PI;
// https://threejs.org/docs/#api/en/math/Vector3
const xUnitVector = new THREE.Vector3(1, 0, 0)
const yUnitVector = new THREE.Vector3(0, 1, 0)
const zUnitVector = new THREE.Vector3(0, 0, 1)

const spitLength = 50;
const spitRadius = 1;
let spitRotation = 0;
let dripsFalling = [];
let dripOrbitRadius = 1.08 * spitRadius;

let camera, renderer, scene, spit;
let theta = 0;

init();

function init() {
  renderer = new THREE.WebGLRenderer({ antialias: true });
  document.body.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x220000);
  addCamera();
  addLight();

  spit = makeSpit();

  window.addEventListener('resize', restart);
  restart();
  scene.add(spit);
  addDrip();
  animate();
}

function restart() {
  const { innerWidth, innerHeight } = window;
  renderer.setSize(innerWidth-17, innerHeight-15);
  renderer.setPixelRatio(window.devicePixelRatio);
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
}

// Create the spit along the x axis, centered on the origin

function makeSpit() {
  const geometry = new THREE.CylinderGeometry(spitRadius, spitRadius, spitLength, 6);
  // https://threejs.org/docs/#api/en/materials/MeshLambertMaterial
  const material = new THREE.MeshLambertMaterial({ color: 0xCCCCFF });
  // https://threejs.org/docs/#api/en/objects/Mesh
  const mesh = new THREE.Mesh(geometry, material);
  mesh.rotation.z = -pi/2; // Rotate from along the y (vertical) axis to x = -len/2..len/2

  return mesh;
}

function addCamera() {
  // https://threejs.org/docs/#api/en/cameras/PerspectiveCamera
  camera = new THREE.PerspectiveCamera(70, 1, 0.1, 100);
  camera.position.set(-0.45*spitLength, 3, 12);
  camera.lookAt(-0.31*spitLength, 2, 0); // Default -ve z (into screen)
}

function addLight() {
  // https://threejs.org/docs/#api/en/lights/PointLight
  const light = new THREE.PointLight(0xFFFFFF, 2);
  light.position.set(-spitLength, 10, 10);
  scene.add(light);
}

function animate() {
  spit.rotateOnAxis(yUnitVector, 0.01);
  spitRotation += 0.01;
  dripsFalling = dripsFalling.filter(falling);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function addDrip() {
  const dripRadius = 0.3;
  const geometry = new THREE.SphereGeometry(dripRadius);
  // https://www.rapidtables.com/web/color/RGB_Color.html
  const material = new THREE.MeshBasicMaterial( { color: randomColour() } );
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(randomAlongSpit(), 20, 0); // Relative to spit vertical orientation
  scene.add(mesh);
  dripsFalling.push(mesh);
  setTimeout(addDrip, 5)
}

function falling(drip) {
  if ((drip.position.y -= 0.2) > dripOrbitRadius) return true;
  scene.remove(drip);
  stickDripToSpit(drip);
  return false;
}

function stickDripToSpit(drip) {
  // Rotate drip to spit original position along the y axis, given the spit's current rotation
  const r = drip.position.y;
  drip.position.set(-r*Math.cos(spitRotation), drip.position.x, -r*Math.sin(spitRotation));
  dripOrbitRadius += 0.001;

  spit.add(drip);
}

function randomAlongSpit() { return -0.5*spitLength + spitLength * Math.random()**4 }

function randomColour() { return any(0xE47808, 0xE07006, 0xDC6804, 0xD86002) }

function any(...args) { return args[Math.floor(args.length * Math.random())] }

function rand(min, max) { return Math.floor(min + (max-min+1) * Math.random()) }
</script>
</body>
</html>
