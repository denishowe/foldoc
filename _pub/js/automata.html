<!DOCTYPE HTML>
<!-- saved from url=(0040)http://foldoc.org/pub/js/automata.html -->
<html>
<head>
<title>Cellular Automata</title>
<meta charset="UTF-8">
<style type="text/css">

body {
  overflow: hidden; /* Prevent scroll bars with no margin */
  background-color: white;
}

</style>
</head>
<body>
<!--
	http://foldoc.org/pub/js/automata.html
	c:\progra~1\intern~1\iexplore.exe -k %USERPROFILE%\Projects\FOLDOC\foldoc\pub\js\automata.html
  -->
<canvas id="canvas" />
<script>
// todo

// Main entry point.  Restart once they stop resizing.

const maxCycles = 2000;
const botsPerCell = 0.5;
const maxEnergy = 500;									// Initial energy

window.onkeydown = function keyDown(e) {
	const kc = e.keyCode, ks = String.fromCharCode(kc);
	// console.log('key', kc, ks);
	if (kc == 17 || kc == 18) return;			// Ignore Alt keys
	if (kc == 27) return close_window();	// Esc key --> close window
	if (ks == ' ') return run.startStop();
	if (ks == 'S') return run.changeSpeed();
}

/// Run ////////////////////////////////////////////////////////////////////////////////////////////

// Singleton for whole program

let run;

class Run {
	constructor() {
		run = this;
		Colour.init();
		Direction.init();
		Cell.init(16); // Cell width and height in pixels
	  Grid.init();
  	this.reset();
	}

	// Start, resize or all dead

	reset() {
	  Bot.reset();
  	this.periods = [0, 100, 500];
  	this.t = 0;
	  this.start();
	}

	startStop() { this.running ? this.stop() : this.start() }

	stop() { this.running = false }

	start() {
		this.running = true;
		this.step();
	}

	step() {
		if (! this.running) return;
		const numAlive = Bot.step();
		if (this.t++ > maxCycles || ! numAlive) // Long run or all dead?
			return this.reset();
		const [t] = this.periods;
		const _this = this;
		setTimeout(() => requestAnimationFrame(() => _this.step()), t);
	}

	changeSpeed() {
		this.periods.push(this.periods.shift());
		console.log('period', this.periods[0]);
	}
}

/// Bot ////////////////////////////////////////////////////////////////////////////////////////////

class Bot {
	constructor(index) {
	  this.pos = Grid.anyEmpty();

 		if (! this.pos) return;

		this.pos.occupant(this);
		this.colour = Colour.colourful(index, Bot.initialNum);
		this.rules = Bot.best && p(0.9) ? Bot.best.mutatedRules() : Bot.randomRules();
		this.setRuleIndexes();
		this.ruleIndex = 0;
		this.energy = Bot.energy();
		this.points = 0;
	}

	// Recreate all Bots according to the screen size

	static reset() {
		if (Bot.best) Bot.best.show();
		Bot.initialNum = Math.floor(Grid.numCells * botsPerCell);
		Bot.all = [];
		for (let i = 0; i < Bot.initialNum; i++)
			Bot.all.push(new Bot(i));
		Bot.all.forEach(b => b.draw());		// Draw all at once
		Bot.best = undefined;
	}

	// Return random initial fraction of max energy

	static energy() { return Math.floor((0.5 + 0.5 * Math.random()) * maxEnergy) }

	// Run one step of bot activity and return number left alive

	static step() {
		Grid.clearClaims();
		Bot.all.map(b => b.calc());		// Claim new positions
		Bot.all.map(b => b.move());		// Then move
		Bot.all = Bot.all.filter(b => b.isLive());
		// console.log('Pop', Bot.all.length);

		return Bot.all.length;
	}

	// Return a single rule loop

	static randomRules() { return [Rule.random()] }

	// If bot's current Rule is active at position pos, set the bot's next position
	// unless off the grid.  Advance bot's pointer to next rule.  Claim new or old pos.

	calc() {
		const rule = this.rules[this.ruleIndex];
		this.ruleIndex = (this.ruleIndex + 1) % this.rules.length; // Point Bot to next rule
		const action = rule.isActiveAt(this.pos) && rule.action;
		this.next_pos = action && this.pos.cellAtVector(action);
		(this.next_pos || this.pos).claim(true);	// Claim new or current pos
	}

	// If new position is empty and I'm sole claimant, move there.  Die if out of energy.

	move() {
		let n = this.next_pos;
		if (n && n.claim() != 1) n = false;	// Drop disputed claim
		this.energy--;
		const dead = ! this.isLive();
		if (n || dead) {
			this.pos.occupant(undefined);		// Clear old pos
			this.draw();
			if (dead) return;
			const prev = this.previous_pos;
			if (! n.equal(prev) && ! n.equal(this.pos)) this.energy += 5;
			this.points++;
			if (! Bot.best || this.points > Bot.best.points) Bot.best = this;
			this.previous_pos = this.pos;
			this.pos = n;
			n.occupant(this);
		}
		this.draw();							// Draw old/new pos, colour
	}

	isLive() { return this.energy > 0 }

	draw() { this.pos.draw() }

	show() {
		const bs = this.toString();
		const p = this.points;
		const c = this.colour.toString();
		console.log('%cbest%c %s %d points', `color: ${ c }`, 'color: black', bs, p);
	}

	// Bot dies if its position is occupied by another bot

	check() {
		const p = this.pos;
		const o = p.occupant();
		if (o == this) return;
		console.log(this + ' vs ' + o);
		Bot.stop();
	}

	// Return black faded towards white as the Bot's energy decreases

	borderColour() {
		const k = 1 - this.energy / maxEnergy;

		return Colour.white.multiply(k < 0 ? 0 : k);
	}

	// Return a randomly modified copy of the Bot's rules

	mutatedRules() {
		const rules = this.rules.clone();
		// todo maybe remove a rule
		const newRule = Rule.random();
		newRule.mutate(rules);
		rules.push(newRule);

		return rules;
	}

	setRuleIndexes() { this.rules.forEach((r, i) => r.index = i) }

	toString() { return (this.rules || []).map(r => r.toString()).join(' ') }
}

/// Rule ////////////////////////////////////////////////////////////

// A Rule has a look direction and wanted type (off, empty, bot) and an action
// direction.  Its index is set according to its position in a Bot's rules.


class Rule {
	constructor(look, want, action) {
		this.look = look;
		this.want = want;
		this.action = action || Direction.random();
	}

	static random() { return new Rule(Direction.random(), Cell.types.any()) }

	// A Rule is active at `pos` if the type of object in the look direction from `pos` is the rule's want

	isActiveAt(pos) { return pos.cellAtVector(this.look).type?.() == this.want }

	clone() { return new Rule(this.look, this.want, this.action) }

	// Randomly change the rule

	mutate(rules) {
		const r = Math.random();
		if (r < 0.2) {
			this.look = Direction.random();
		} else if (r < 0.4) {
			this.want = Cell.types.any();
		} else if (r < 0.6) {
			this.action = Direction.random();
		} else if (r < 0.8) {
			this.next = rules.anyIndex();	// Set random jump
		}
	}

	toString() {
		const { action, index, look, want } = this;
		const wantString = Cell.typeString[want];

		return `${ index }:${ look.toString() }${ wantString }${ action.toString() }`;
	}
}

/// Direction ///////////////////////////////////////////////////////////////

class Direction {
	constructor([symbol, x, y]) { this.symbol = symbol; this.x = x; this.y = y }

	static init() {
		Direction.all = [
			['N',  0, -1, 1],	// y increases downwards
			['E',  1,  0, 2],
			['S',  0,  1, 4],
			['W', -1,  0, 8]
		].map(dxyb => new Direction(dxyb));
	}

	// Return a random direction from NESW

	static random() { return Direction.all.any() }

	toString() { return this.symbol }
}

/// Grid ///////////////////////////////////////////////////////////

class Grid {
	static init() {
		this.grid = [];
		const ww = window.innerWidth, wh = window.innerHeight;
		const cw = this.round(ww), ch = this.round(wh);
		this.ctx = this.context(ww, wh, cw, ch);
		this.ctx.fillStyle = 'blue';
		this.ctx.rect(0, 0, cw, ch);
		// Set the inclusive max x and y for the given width and height in pixels
		this.xMax = Math.floor(cw / Cell.size - 1);
		this.yMax = Math.floor(ch / Cell.size - 1);
		this.numCells = (this.xMax + 1) * (this.yMax + 1);
	}

	// Return a context for canvas

	static context(ww, wh, cw, ch) {
		const canvas = document.getElementById('canvas');
		canvas.width = cw; canvas.height = ch;
		// Centre the canvas in the window
		canvas.style.marginLeft = ((ww - cw)/2 - 11) + 'px';
		canvas.style.marginTop	= ((wh - ch)/2 - 11) + 'px';
		canvas.style.border = 'solid';
		canvas.onclick = run.startStop;

		return canvas.getContext('2d');
	}

	// Round window coord to a multiple of the grid size.

	static round(x) { return Math.floor((x-6) / Cell.size) * Cell.size }

	// Return a random empty position

	static anyEmpty() {
		for (let n = 1000; n--; ) {
			const pos = this.randomCell();
			if (! pos.occupant()) return pos;
		}
	}

	static randomCell() { return new Cell(rand(0, Grid.xMax), rand(0, Grid.yMax)) }

	static clearClaims() { this.claims = [] }
}

class Cell {
	constructor(x, y) { this.x = x; this.y = y }

	static init(cellSize) {
		this.size = cellSize;
		this.types = ['empty', 'bot', 'off'];
		this.typeString = { empty: '∅', bot: '⬛', off: '-'}
	}

	equal(p) { return p && this.x == p.x && this.y == p.y }

	// Return canvas coords

	origin() { return {x: this.x * Cell.size, y: this.y * Cell.size} }

	// Get or set the occupant of this cell

	occupant(newOccupant) {
		let row = Grid.grid[this.y];
		if (! row) {
			if (! arguments.length) return undefined;
			row = Grid.grid[this.y] = [];
		}
		if (arguments.length)				// New occupant may be undefined
			row[this.x] = newOccupant;

		return row[this.x];
	}

	// Return true if cell is on the grid

	isOnGrid({ x, y } = this) { return x >= 0 && x <= Grid.xMax && y >= 0 && y <= Grid.yMax }

	// Return the type of thing in this cell: 'off' (off screen), 'empty' or 'bot'

	type() { return !this.isOnGrid() ? 'off' : this.occupant() ? 'bot' : 'empty' }

	// If `add`, increment the claims on the cell.  Return the total.

	claim(add) {
		const { x, y } = this;
		let row = Grid.claims[y];
		if (! row) {
			if (! add) return 0;
			row = Grid.claims[y] = [];
		}
		row[x] = row[x] || 0;
		if (add) row[x]++;

		return row[x];
	}

	// Return the cell at this position plus vector v, or false if off grid

	cellAtVector(v) {
		const x = this.x + v.x, y = this.y + v.y;

		return this.isOnGrid({ x, y }) && new Cell(x, y);
	}

	draw() {
		const { x, y } = this.origin();
		const occupant = this.occupant();
		const c = Grid.ctx;
		const margin = occupant ? 2 : 0;

		c.strokeStyle = occupant ? occupant.borderColour().toString() : 'white';
		c.fillStyle = occupant ? occupant.colour.toString() : 'white';
		c.beginPath();
		c.rect(x + margin, y + margin, Cell.size - 2*margin, Cell.size - 2*margin);
		c.fill();
		c.stroke();
		c.closePath();
	}

	toString() { return '(' + this.x + ',' + this.y + ')' }
}

/// Colour ///////////////////////////////////////////////////////////

// Return a colour with components r, g, b

class Colour {
	constructor(r, g, b) { this.r = r; this.g = g; this.b = b }

	static init() {
		this.black = new Colour(0, 0, 0);
		this.white = new Colour(255, 255, 255);
		this.grey  = new Colour(127, 127, 127);
		this.light_green = new Colour(50, 255, 50);
	}

	// Return the RGB colour i out of 0..n-1 equally
	// spaced hues with maximum saturation and luminance

	static colourful(i, n) {
		const h = 6 * i / n;         				          // n equally spaced hues in 0..6
		const x = h % 1;
		let r, g, b;					        				        // x = 0 .. 1

         if (h < 1) { r = 1;   g = x;   b = 0   }	// red	   .. yellow
		else if (h < 2) { r = 1-x; g = 1;   b = 0   }	// yellow  .. green
		else if (h < 3) { r = 0;   g = 1;   b = x   }	// green   .. cyan
		else if (h < 4) { r = 0;   g = 1-x; b = 1   }	// cyan	   .. blue
		else if (h < 5) { r = x;   g = 0;   b = 1   }	// blue	   .. magenta
		else			      { r = 1;   g = 0;   b = 1-x }	// magenta .. red

		return (new Colour(r, g, b)).multiply(255);
	}

	// Return colour with each component multiplied by k

	multiply(k) { return this.map(function (x) { return Math.floor(k * x) } ) }

	map(f) { return new Colour(f(this.r), f(this.g), f(this.b)) }

	// Return a JavaScript colour string, 'rgb(R,G,B)'

	toString() { return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')' }
}

/// Array extentions /////////////////////////////////////////////////

// Instance methods of MyArray are copied to Array below

class MyArray {
	// Return clones of the array's elements

	clone() { return this.map(x => x.clone()) }

	// Return a random index of the array

	anyIndex() { return Math.floor(this.length * Math.random()) }

	// Return a random element of the array

	any() { return this[this.anyIndex()] }
}

Object.getOwnPropertyNames(MyArray.prototype)
	.forEach(method => Array.prototype[method] = MyArray.prototype[method]);

/// Utils ////////////////////////////////////////////////////////////

function p(probability) { return Math.random() < probability }

// Return a random int, min <= r <= max

function rand(min, max) { return Math.floor(min + (max+1 - min) * Math.random()) }

function close_window() {
	// JavaScript can close the window if it opened it.	 It can't
	// open a page from a different domain, including no domain.
	// http://thecodecave.com/2006/07/20/how-to-get-around-access-is-denied-in-a-windowopen-javascript-call/
	window.open(location.href, '_self', '').close();
}

new Run();

</script>
</body>
</html>
