<!DOCTYPE HTML>
<!-- saved from url=(0040)http://foldoc.org/pub/js/automata.html -->
<html>
<head>
<title>Cellular Automata</title>
<meta charset="UTF-8">
<style type="text/css">

body {
  overflow: hidden; /* Prevent scroll bars with no margin */
  background-color: white;
}

</style>
</head>
<body>
<!--
	http://foldoc.org/pub/js/automata.html
	c:\progra~1\intern~1\iexplore.exe -k %USERPROFILE%\Projects\FOLDOC\foldoc\pub\js\automata.html
  -->
<canvas id="canvas" />
<script>
// todo

// Main entry point.  Restart once they stop resizing.

const maxCycles = 2000;
const botsPerCell = 0.5;
const maxEnergy = 500;									// Initial energy

window.onkeydown = function keyDown(e) {
	const kc = e.keyCode, ks = String.fromCharCode(kc);
	// console.log('key', kc, ks);
	if (kc == 17 || kc == 18) return;			// Ignore Alt keys
	if (kc == 27) return close_window();	// Esc key --> close window
	if (ks == ' ') return run.startStop();
	if (ks == 'S') return run.changeSpeed();
}

/// Run ////////////////////////////////////////////////////////////////////////////////////////////

// Singleton

let run;

class Run {
	constructor() {
		run = this;
		Colour.init();
		Direction.init();
		Cell.init(16); // Cell width and height in pixels
	  Grid.init();
  	this.reset();
	}

	// Start, resize or all dead

	reset() {
	  Bot.reset();
  	this.periods = [0, 100, 500];
  	this.t = 0;
	  this.start();
	}

	startStop() { this.running ? this.stop() : this.start() }

	stop() { this.running = false }

	start() {
		this.running = true;
		this.step();
	}

	step() {
		if (! this.running) return;
		const numAlive = Bot.step();
		if (this.t++ > maxCycles || ! numAlive) // Long run or all dead?
			return this.reset();
		const [t] = this.periods;
		const _this = this;
		setTimeout(() => requestAnimationFrame(() => _this.step()), t);
	}

	changeSpeed() {
		this.periods.push(this.periods.shift());
		console.log('period', this.periods[0]);
	}
}

/// Bot ////////////////////////////////////////////////////////////////////////////////////////////

class Bot {
	constructor(index) {
	  this.pos = Grid.anyEmpty();

 		if (! this.pos) return;

		this.pos.occupant(this);
		this.colour = Colour.colourful(index, Bot.initialNum);
		this.rules = Bot.best ? Bot.best.mutatedRules() : Direction.random();
		this.ruleIndex = 0;
		this.energy = Bot.energy();
		this.points = 0;
	}

	// Recreate all Bots according to the screen size

	static reset() {
		if (Bot.best) Bot.best.show();
		Bot.initialNum = Math.floor(Grid.numCells * botsPerCell);
		Bot.all = [];
		for (let i = 0; i < Bot.initialNum; i++)
			Bot.all.push(new Bot(i));
		Bot.all.forEach(b => b.draw());		// Draw all at once
		Bot.best = undefined;
	}

	// Return random initial fraction of max energy

	static energy() { return Math.floor((0.5 + 0.5 * Math.random()) * maxEnergy) }

	// Run one step of bot activity and return number left alive

	static step() {
		Grid.clearClaims();
		Bot.all.map(b => b.calc());		// Claim new positions
		Bot.all.map(b => b.move());		// Then move
		Bot.all = Bot.all.filter(b => b.isLive());
		// console.log('Pop', Bot.all.length);

		return Bot.all.length;
	}

	// Set the bot's next position unless off the grid and claim it.  Advance bot's pointer.

	calc() {
		const rule = this.rules[this.ruleIndex];
		this.ruleIndex = (this.ruleIndex + 1) % this.rules.length; // Point Bot to next rule
		this.next_pos = this.pos.cellInDirection(rule);
		this.next_pos?.claim(true);	// Claim new pos
	}

	// If new position is empty and I'm sole claimant, move there.  Die if out of energy.

	move() {
		let n = this.next_pos;
		if (n && n.claim() !== 1) n = undefined; // Drop disputed claim
		this.energy--;
		const dead = ! n || ! this.isLive();
		this.pos.occupant(undefined);		// Clear old pos
		this.draw();
		if (dead) return;
		const prev = this.previous_pos;
		if (! n.equal(prev) && ! n.equal(this.pos)) this.energy += 5;
		this.points++;
		if (! Bot.best || this.points > Bot.best.points) Bot.best = this;
		this.previous_pos = this.pos;
		this.pos = n;
		n.occupant(this);
		this.draw();							// Draw old/new pos, colour
	}

	isLive() { return this.energy > 0 }

	draw() { this.pos.draw() }

	show() {
		const bs = this.toString();
		const p = this.points;
		const c = this.colour.toString();
		console.log('%cbest%c %s %d points', `color: ${ c }`, 'color: black', bs, p);
	}

	// Return black faded towards white as the Bot's energy decreases

	borderColour() {
		const k = 1 - this.energy / maxEnergy;

		return Colour.white.multiply(k < 0 ? 0 : k);
	}

	// Return a randomly modified copy of the Bot's rules

	mutatedRules() {
		const { rules } = this;
		const n = rules.length;
		const d = Direction.random();
		return [
			{ ok: true,		f: () => rules },						// No change
			{ ok: true,		f: () => d },								// New set
			{ ok: true,		f: () => rules.setAny(d) },	// Change a rule
			{ ok: n >  1,	f: () => rules.dropAny() },	// Remove a rule
			{ ok: n < 10,	f: () => rules + d },				// Append a rule
			{ ok: n <  5,	f: () => rules + rules },		// Duplicate set
		].filter(change => change.ok).any().f();
	}

	toString() { return this.rules }
}

/// Direction ///////////////////////////////////////////////////////////////

class Direction {
	static init() {
		this.vector = {
			N: { dx: 0,  dy: -1 },	// y increases downwards
			E: { dx: 1,  dy: 0 },
			S: { dx: 0,  dy: 1 },
			W: { dx: -1, dy: 0 },
		};

		this.directions = [...Object.keys(this.vector)];
	}

	// Return a random direction from NESW

	static random() { return this.directions.any() }
}

/// Grid ///////////////////////////////////////////////////////////

class Grid {
	static init() {
		this.grid = [];
		const ww = window.innerWidth, wh = window.innerHeight;
		const cw = this.round(ww), ch = this.round(wh);
		this.ctx = this.context(ww, wh, cw, ch);
		this.ctx.fillStyle = 'blue';
		this.ctx.rect(0, 0, cw, ch);
		// Set the inclusive max x and y for the given width and height in pixels
		this.xMax = Math.floor(cw / Cell.size - 1);
		this.yMax = Math.floor(ch / Cell.size - 1);
		this.numCells = (this.xMax + 1) * (this.yMax + 1);
	}

	// Return a context for canvas

	static context(ww, wh, cw, ch) {
		const canvas = document.getElementById('canvas');
		canvas.width = cw; canvas.height = ch;
		// Centre the canvas in the window
		canvas.style.marginLeft = ((ww - cw)/2 - 11) + 'px';
		canvas.style.marginTop	= ((wh - ch)/2 - 11) + 'px';
		canvas.style.border = 'solid';
		canvas.onclick = run.startStop;

		return canvas.getContext('2d');
	}

	// Round window coord to a multiple of the grid size.

	static round(x) { return Math.floor((x-6) / Cell.size) * Cell.size }

	// Return a random empty position

	static anyEmpty() {
		for (let n = 1000; n--; ) {
			const pos = this.randomCell();
			if (! pos.occupant()) return pos;
		}
	}

	static randomCell() { return new Cell(rand(0, this.xMax), rand(0, this.yMax)) }

	static clearClaims() { this.claims = [] }

	static isOnGrid(x, y) { return x >= 0 && x <= this.xMax && y >= 0 && y <= this.yMax }
}

/////////////////////////////////////////////////////////////////////////////////////

class Cell {
	constructor(x, y) { this.x = x; this.y = y }

	static init(size) {
		this.size = size;
		// this.types = ['empty', 'bot', 'off'];
		// this.typeString = { empty: '∅', bot: '⬛', off: '-'}
	}

	equal(p) { return p && this.x == p.x && this.y == p.y }

	// Return canvas coords

	origin() { return {x: this.x * Cell.size, y: this.y * Cell.size} }

	// Get or set the occupant of this cell

	occupant(newOccupant) {
		let row = Grid.grid[this.y];
		if (! row) {
			if (! newOccupant) return undefined; // Set undefined or get in non-existent row
			row = Grid.grid[this.y] = [];
		}
		if (arguments.length)				// New occupant may be undefined
			row[this.x] = newOccupant;

		return row[this.x];
	}

	// Return the type of thing in this cell: 'off' (off screen), 'empty' or 'bot'

	// type() { return !this.isOnGrid() ? 'off' : this.occupant() ? 'bot' : 'empty' }

	// If `add`, increment the claims on the cell.  Return the total.

	claim(add) {
		const { x, y } = this;
		let row = Grid.claims[y];
		if (! row) {
			if (! add) return 0;
			row = Grid.claims[y] = [];
		}
		row[x] = row[x] || 0;
		if (add) row[x]++;

		return row[x];
	}

	// Return the cell in direction d from this position, or undefined if off grid

	cellInDirection(d) {
		let { x, y } = this;
		const { dx, dy } = Direction.vector[d];
		x += dx; y += dy;

		return Grid.isOnGrid(x, y) ? new Cell(x, y) : undefined;
	}

	draw() {
		const { x, y } = this.origin();
		const occupant = this.occupant();
		const c = Grid.ctx;
		const margin = occupant ? 2 : 0;

		c.strokeStyle = occupant ? occupant.borderColour().toString() : 'white';
		c.fillStyle = occupant ? occupant.colour.toString() : 'white';
		c.beginPath();
		c.rect(x + margin, y + margin, Cell.size - 2*margin, Cell.size - 2*margin);
		c.fill();
		c.stroke();
		c.closePath();
	}

	toString() { return '(' + this.x + ',' + this.y + ')' }
}

/// Colour ///////////////////////////////////////////////////////////

// Return a colour with components r, g, b

class Colour {
	constructor(r, g, b) { this.r = r; this.g = g; this.b = b }

	static init() {
		this.black = new Colour(0, 0, 0);
		this.white = new Colour(255, 255, 255);
		this.grey  = new Colour(127, 127, 127);
		this.light_green = new Colour(50, 255, 50);
	}

	// Return the RGB colour i out of 0..n-1 equally
	// spaced hues with maximum saturation and luminance

	static colourful(i, n) {
		const h = 6 * i / n;         				          // n equally spaced hues in 0..6
		const x = h % 1;
		let r, g, b;					        				        // x = 0 .. 1

         if (h < 1) { r = 1;   g = x;   b = 0   }	// red	   .. yellow
		else if (h < 2) { r = 1-x; g = 1;   b = 0   }	// yellow  .. green
		else if (h < 3) { r = 0;   g = 1;   b = x   }	// green   .. cyan
		else if (h < 4) { r = 0;   g = 1-x; b = 1   }	// cyan	   .. blue
		else if (h < 5) { r = x;   g = 0;   b = 1   }	// blue	   .. magenta
		else			      { r = 1;   g = 0;   b = 1-x }	// magenta .. red

		return (new Colour(r, g, b)).multiply(255);
	}

	// Return colour with each component multiplied by k

	multiply(k) { return this.map(function (x) { return Math.floor(k * x) } ) }

	map(f) { return new Colour(f(this.r), f(this.g), f(this.b)) }

	// Return a JavaScript colour string, 'rgb(R,G,B)'

	toString() { return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')' }
}

/// Extend built-in classes /////////////////////////////////////////////////

// Instance methods of MyClass are copied to Class below

class MyArray {
	// Return a random element of the array

	any() { return this[this.anyIndex()] }

	// Return a random index of the array or zero if it's empty

	anyIndex() { return Math.floor(this.length * Math.random()) }
}
Object.getOwnPropertyNames(MyArray.prototype)
	.forEach(method => Array.prototype[method] = MyArray.prototype[method]);

class MyString {
	anyIndex() { return Math.floor(this.length * Math.random()) }

	dropAny() { return this.setAny() }

	setAny(x = '') {
		const i = this.anyIndex();

		return this.slice(0, i) + x + this.slice(i + 1);
	}
}
Object.getOwnPropertyNames(MyString.prototype)
	.forEach(method => String.prototype[method] = MyString.prototype[method]);

/// Utils ////////////////////////////////////////////////////////////

function p(probability) { return Math.random() < probability }

// Return a random int, min <= r <= max

function rand(min, max) { return Math.floor(min + (max+1 - min) * Math.random()) }

function close_window() {
	// JavaScript can close the window if it opened it.	 It can't
	// open a page from a different domain, including no domain.
	// http://thecodecave.com/2006/07/20/how-to-get-around-access-is-denied-in-a-windowopen-javascript-call/
	window.open(location.href, '_self', '').close();
}

new Run();

</script>
</body>
</html>
