<!DOCTYPE html>
<!-- Create a map -->

<html>
<head>
<title>Make a Map</title>
<meta charset="UTF-8">
<link rel="canonical" href="http://foldoc.org/pub/js/make-map.html">
<style type="text/css">body { overflow: hidden; margin: 0 }</style>
</head>
<body>
<canvas id="canvas">No canvas</canvas>
<script>

const config = {
	lineWidth: 2,
	loopDelay: 0,
	margin: 3,
	numColours: 12,
	splitableRadius: 30,
};

// Box  ///////////////////////////////////////////////////////////////////////////////////////////

// A rectangular area that almost fills the window

class Box {
	static resize() {
		const canvas = document.getElementById('canvas');
		const { innerWidth, innerHeight } = window;
		const { margin } = config;
		canvas.height = innerHeight - 2 * margin;
		canvas.width = innerWidth - 2 * margin;
		canvas.style.marginLeft = `${margin}px`;	// Centre in window
		canvas.style.marginTop	= `${margin}px`;
		this.ctx = canvas.getContext('2d');

		this.init();
	}

	static handleClick(x, y) { this.clicked = { x, y } }

	static handleKey(k) { console.log('Key event', k) }

	static init() {
		Colour.init();

		const { ctx } = this;
		const { canvas: { height, width } } = ctx;
		ctx.strokeStyle = Colour.black.string;
		ctx.lineWidth = config.lineWidth;
		const points = [[0, 0], [width, 0], [width, height], [0, height]]
			.map(xy => new Point(this, ...xy));
		this.regions = [new Region(this, points, Colour.random())];

		this.run();
	}

	static run() { loopWhile(() => this.step(), config.loopDelay) }

	static step() { this.draw(); return this.split() }

	static split() {
		const { regions } = this;
		const ir = regions.withMax(region => region.splitability);
		const newRegions = regions[ir].split();

		if (! newRegions) return false;

		this.regions.splice(ir, 1, ...newRegions);

		return true;
	}

	static draw() { this.regions.forEach(region => region.draw()) }
}

// Point ///////////////////////////////////////////////////////////////////////////////////////////

class Point {
	constructor(box, x, y) {
		this.box = box;
		this.x = x;
		this.y = y;
	}

	// The centrum of a set of points is (mean x, mean y)

	static centrum(ps) {
		const n = ps.length;
		if (! n) throw('');
		let xt = 0, yt = 0;
		ps.forEach(({ x, y}) => { xt += x; yt += y });

		return new Point(undefined, xt/n, yt/n);
	}

	// Return the distance from this point to { x, y }

	distance({ x, y }) { return Math.sqrt((this.x - x) ** 2 + (this.y - y) ** 2) }

	lineTo() {
		const { box: { ctx }, x, y } = this;
		ctx.lineTo(x, y);
	}

	moveTo() {
		const { box: { ctx }, x, y } = this;
		ctx.moveTo(x, y);
	}

	partWayTo(that, f = 0.4 + 0.2 * Math.random()) {
		const g = 1 - f;
		return new Point(
			this.box,
			Math.floor(f * this.x + g * that.x),
			Math.floor(f * this.y + g * that.y),
		);
	}
}

// Region //////////////////////////////////////////////////////////////////////////////////////////

class Region {
	constructor(box, points, colour) {
		this.box = box;
		this.points = points;								// The ring of points defining the region
		this.colour = colour;
		// Store the distance from each point to the next point round the ring
		this.edgeLengths = points.map((p, i) => p.distance(points.modEl(i + 1)));
		this.splitability = this.findSplitability();
	}

	// The region's splitability is the minimum radius of its sides
	// minus the splitableRadius.  A side's "radius" is the distance
	// from its midpoint to the centrum.  splitability > 0 => splitable.

	findSplitability() {
		const { points } = this;

		// return this.edgeLengths.min()**2 * this.edgeLengths.max() - 1E6;

		const c = Point.centrum(points);
		const minRadius = points .map((p, i) => {
			const j = points.modIndex(i + 1);
			const mid = p.partWayTo(points[j], 0.5);
			return c.distance(mid);
		}).min();

		return minRadius - config.splitableRadius;
	}

	draw() {
		const { box, colour: { string }, points } = this;
		const { ctx } = box;
		ctx.beginPath();
		points[0].moveTo();
		points.slice(1).forEach(p => p.lineTo());
		ctx.closePath();
		ctx.fillStyle = string;
		ctx.fill();
		ctx.stroke();												// On top of fill
	}

	// If the region is unsplitable, return null.  Otherwise, return two
	// new regions created by splitting the region along a line from a
	// point on its longest edge to an existing point not on that edge

	split() {
		if (this.splitability < 0) return null;

		const { edgeLengths, points } = this;
		// Find longest edge, points i -> j
		const i = edgeLengths.withMax(x => x);
		const j = points.modIndex(i + 1);
		const mid = points[i].partWayTo(points[j]);
		const otherIndexes = [...points.keys()].filter(k => k !== i && k !== j);
		const k = otherIndexes.any();

		return [this.regionWith(i, mid, k), this.regionWith(k, mid, j)];
	}

	// Return a new region starting with [i] -> mid -> [j]
	// and continuing round this region

	regionWith(i, mid, j) {
		const { points } = this;
		const newPoints = [points[i], mid];
		for (; j !== i; j = points.modIndex(j + 1)) {
			newPoints.push(points[j]);
		}
		return new Region(this.box, newPoints, Colour.random());
	}
}

// Colour //////////////////////////////////////////////////////////////////////////////////////////

// A Colour has:
// - vec = [R, G, B] containing ints 0..255
// - string = "rgb(R,G,B)"

class Colour {
	// Store the given [R, G, B], where 0 <= R < 256, etc.,
	// as the new Colour's vec and "rgb(R,G,B)" string.

	constructor(vecOrFun) {
		const v = typeof vecOrFun === 'function' ? Colour.map(vecOrFun) : vecOrFun;
		this.vec = v.map(cpt => Math.min(Math.max(cpt, 0), 255.999999));
		const s = this.vec.map(cpt => Math.floor(cpt)).join(',');
		this.string = `rgb(${s})`;
	}

	// Fill the palette with n equally spaced hues as rgb() strings

	static init() {
		const { numColours } = config;
		this.palette = this.makePalette(numColours);
		this.black = new Colour([0, 0, 0]);
		this.white = new Colour([255, 255, 255]);
		this.transparent = 'rgba(0,0,0,0)';
	}

	// Create a palette of numColours equally spaced hues

	static makePalette(numColours) {
		const hueOffset = Math.random();
		return zeroTo(numColours)
			.map(i => Colour.fromHue(hueOffset + i / numColours));
	}

	// Return a new Colour with hue in 0..1 and maximum saturation and luminance

	static fromHue(hue) {
		const h = (6 * hue) % 6;	// n equally spaced hues in [0..6)
		const x = h % 1;					// x = 0 .. 1
		const y = 1 - x;					// y = 1 .. 0
		const c = [								// [R, G, B] in 0..1
			[1, x, 0],							// red	   .. yellow
			[y, 1, 0],							// yellow  .. green
			[0, 1, x],							// green   .. cyan
			[0, y, 1],							// cyan	   .. blue
			[x, 0, 1],							// blue	   .. magenta
			[1, 0, y],								// magenta .. red
		][Math.floor(h)];
		// Convert to [R, G, B] in 0..255
		const vec = c.map(cpt => 255.999999 * cpt + rand(-128, 128));

		return new Colour(vec);
	}

	static map(f) { return nResults(3, f) }

	static random() { return this.palette.any() }

	static reallyRandom() { return new Colour(_ => rand(0, 255)) }

	// L in 0..1 = (max(RGB) + min(RGB)) / 2; where R, G, B in 0..255

	luminosity() { return (this.vec.min() + this.vec.max()) / (2 * 256) }

	// S in 0..1 = L == 1 ? 0 : (max(RGB) — min(RGB)) / (1 — |2L - 1|)
	// where R, G, B in 0..255; L in 0..1

	saturation() {
		const desat = 1 - Math.abs(2 * this.luminosity() - 1);

		return desat === 0 ? 0 : (this.vec.max() - this.vec.min()) / (256 * desat);
	}

	boring() { return this.saturation() < 0.2 }

	setStyles(ctx) {
		const { string } = this;
		ctx.fillStyle = string;
		ctx.strokeStyle = string;
	}
}


// Array  //////////////////////////////////////////////////////////////////////////////////////////

Array.prototype.any = function any() { return this[Math.floor(this.length * Math.random())] };

Array.prototype.last = function last() { return this[this.length - 1] };

Array.prototype.min = function min() { return Math.min.apply(null, this) };
Array.prototype.max = function max() { return Math.max.apply(null, this) };

// Return the index i for which f(a[i]) is biggest

Array.prototype.withMax = function withMax(f) {
	let iMax, fMax;
	this.forEach((el, i) => {
		const fi = f(el);
		if (iMax === undefined || fi > fMax) { iMax = i; fMax = fi }
	});
	return iMax;
};

// Return i modulo the length of the array

Array.prototype.modIndex = function modIndex(i) { return i % this.length };

Array.prototype.modEl = function modIndex(i) { return this[this.modIndex(i)] };

// Return the array indexes in order of increasing f(a[i])

Array.prototype.sortWith = function sortWith(f) {
	return [...this.keys()]
		.sort((a, b) => f(this[a]) - f(this[b]));
};

Array.prototype.sum = function sum() { return this.reduce((el, acc) => acc + el, 0) };

Array.prototype.shuffle = function shuffle() {
	return this.sort(() => prob(0.5));
};


// Events & Window ////////////////////////////////////////////////////////////////////////////////

document.onclick = click;
document.onmousemove = click;

function click(e) {
	if (e.buttons === 2) return;			// Ignore right-click
	// Stationary click -> type 'click'.  Drag -> mousemove.
	// Ignore first "click" after movement.
	const clickEvent = e.type === 'click' && !click.moving;
	if (clickEvent) fullScreen();
	// Ignore mouse move unless button pressed and moved > 1 pixel
	click.moving = e.type === 'mousemove' && e.buttons && click.old_x
		&& Math.abs(e.clientX - click.old_x) + Math.abs(e.clientY - click.old_y) > 1;
	click.old_x = e.clientX;
	click.old_y = e.clientY;
	if (!clickEvent && !click.moving) return;
	Box.handleClick(e.offsetX, e.offsetY);
}

click.moving = false;
click.old_x = 0;

// Request for full screen must be initiated by user action in Chrome or Firefox
// Firefox fix - https://stackoverflow.com/a/27078920/285129
// about:config > full-screen-api.allow-trusted-requests-only: false

function fullScreen() {
	const d = document.documentElement;
	const f = d.requestFullscreen || d.webkitRequestFullscreen || d.msRequestFullscreen;
	if (!f) { console.log('No full screen API'); return }
	f.call(d);
}

// Wait until a while after resizing stops

window.onresize = function onresize() { debounce(maybeResize, 1000) }

// Resize the box if the window has changed shape
// Assumes a single use in the program

function maybeResize() {
	const { innerWidth, innerHeight } = window;
	const shape = `${innerWidth}x${innerHeight}`;
	if (shape === (maybeResize.shape || '')) return;
	maybeResize.shape = shape;
	Box.resize();
}

// Handle key press

// onkeypress doesn't get ESC

window.onkeydown = function onKeyDown(e) {
	let k = e.keyCode;
	k = k === 27 ? 'Esc' : String.fromCharCode(k);
	Box.handleKey(k);
};

// Utilities //////////////////////////////////////////////////////////////////////////////////////

// Schedule a call to f after t ms, cancelling any previous scheduled call
// Assumes a single use in the program

function debounce(f, t) {
	if (debounce.timeout) clearTimeout(debounce.timeout);
	debounce.timeout = setTimeout(f, t);
};

function loopWhile(f, t) {
	if (f()) { setTimeout(() => loopWhile(f, t), t) }
}

// Return ints 0 .. n-1

function zeroTo(n) { return n < 1 ? [] : [...Array(n).keys()] }

// Return the results of calling f(i) for i = 0 .. n-1

function nResults(n, f) { return zeroTo(n).map(f) }

function prob(p) { return Math.random() < p }

// Return a random int, min <= r <= max

function rand(min, max, pow) {
	let r = Math.random();
	if (pow) r **= pow;
	return Math.floor(min + (max + 1 - min) * r);
}

// /////////////////////////////////////////////////////////////////////////////////////////////////

// Some browsers call resize on load, Firefox doesn't
// Firefox's window.innerHeight is 1px too big when dev console visible

window.onresize();
</script>
</body>
</html>
