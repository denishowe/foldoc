%Copyright (c) Denis Howe 1992
%You may copy this file freely but you must not charge for it and
%you must not remove this notice.  Please send me a copy of any
%modifications you make.	Denis Howe <dbh@doc.ic.ac.uk>

\documentstyle{slides}
\begin{document}
\pagestyle{plain}

%The rest up to before \end{document} should really go
%in a separate file, say "slides.tex", included with
%\blackandwhite{slides}

\begin{slide}{}
\centering
Introduction to GNU Emacs
\vspace{3cm}

Denis Howe

{\tt dbh@doc.ic.ac.uk}
\end{slide}

\begin{slide}{}
GNU Emacs

The {\em Free Software Foundation}'s editor
\begin{itemize}
\item extensible -- add new functions
\item customizable -- rebind keys, hooks
\item self-documenting -- on-line context-sensitive help
\item real-time display -- WYSIWYG ({\it cf} YAFIYGI)
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{\parbox{16cm}{\tt
This is an example screen. \\
The user has just typed \\
\^{}X\^{}F \\
\rule{0cm}{10cm}
-\,-\,**\,-Emacs:~prog.c~~~~(C)\,-\,-\,-\,23\%-\,-\,-\,-\,-\,-\,- \\
Find file: /homes/dbh/src/\rule[-0.2ex]{0.4em}{2ex}}}
\end{slide}

\begin{slide}{}
Basic concepts
\begin{description}
\item[Buffer]
- A collection of lines (from a file) stored in memory

\item[Window]
- An area of the screen showing the contents of a buffer

\item[Mode line]
- Status line at bottom of window showing file name, position,
modification status, buffer modes, time

\item[Minibuffer/echo area]
- A one-line buffer \\
below mode line for displaying messages and reading parameters

\item[Point]
- Current (cursor) position in a buffer
\end{description}
\end{slide}

\begin{slide}{}
Key sequences

Eg. C-x C-f  =  Control-x Control-f  =  find-file

Keys are:
\begin{description}
\item[Control characters] : \\
C-@ C-a .. C-z TAB LFD RET ESC DEL
\item[Printing characters] : \\
SPC ! .. 0 .. 9 .. @ A~..~Z .. a .. z .. \~{}
\item[Meta key] $\Diamond$ on Sun
\end{description}
\end{slide}

\begin{slide}{}
Key sequences

\vspace{3cm}

{\em Prefix} keys: ESC C-x C-h C-c \\
start a key sequence

Eg. ESC f (two key sequence) \\
or equivalently, M-f (hold Meta key and hit F)

Key sequences execute {\em commands} \\
eg. forward-word

Characters are displayed as, eg. \\
\^{}@ \^{}A \^{}[ \^{}? $\backslash$ 234
\end{slide}

\begin{slide}{}
Starting Emacs from the shell

Try one of {\tt epoch}, {\tt emacs}, {\tt gnu}, {\tt gnuemacs} \\
or {\tt uemacs} (micro-emacs -- not GNU emacs).

Command line arguments
\begin{description}
\item[-nw]
ignore window system (eg. X-windows)
\item[-q]
ignore .emacs file
\item[\em files]
to load and edit
\end{description}
Exiting Emacs

C-x C-c (save-buffers-kill-emacs)
\end{slide}

\begin{slide}{}
Basic editing commands

Printing characters execute the command \\
self-insert-command

Moving around the buffer
\begin{verbatim}
    top of buffer  M-<
  previous screen  M-v
    previous line  C-p

C-a   M-b   C-b           C-f   M-f   C-e
start back  back         forw  forw   end
of    word  char         char  word   of
line                                  line

        next line  C-n
      next screen  C-v
       end of buf  M->
\end{verbatim}
\end{slide}

\begin{slide}{}
Advanced editing commands

\vspace{5cm}
\centering
\LARGE
C-h
\vspace{5cm}
\end{slide}

\begin{slide}{}
More advanced editing commands

Numeric prefix argument. \\
Eg. ESC 7 C-n \\
Repeat C-n 7 times -- down 7 lines

\begin{description}
\item[M-x]
(execute-extended-command) \\
Read a command name from the \\
minibuffer and execute it
\end{description}

Eg. M-x goto-line \\
Move cursor to line number $N$.
Line 1 is the beginning of the buffer

Line number is either prefix argument (ESC $N$ M-x goto-line) or read
from minibuffer
\end{slide}

\begin{slide}{}
The Minibuffer

For input and editing of parameters, eg.\ name of file to load, and
for displaying messages

Provides {\em completion} of file-names, command names, Lisp symbols
etc.

\begin{description}
\item[C-g]
Quit minibuffer input or other activity
\item[TAB, RET]
Complete as much as possible
\item[SPC]
Complete current word
\item[?]
Show all completions
\end{description}
\end{slide}

\begin{slide}{}
On-line help

\vspace{3cm}

C-h followed by:

\begin{tabular}{cll}
A & apropos  & search for help on a word \\
F & function & describe a Lisp function \\
I & info     & documentation browser \\
K & key      & describe a key sequence \\
V & variable & describe a Lisp variable \\
T & tutorial & read about and try commands
\end{tabular}
\end{slide}

\begin{slide}{}
Correcting text

{\em Killed} (deleted) text is saved for later \\
re-insertion

\begin{description}
\item[DEL, C-d]
-- Delete character before/after \\
cursor
\item[M-DEL, M-d]
-- Kill word before/after \\
cursor
\item[C-k]
-- Kill to end of line

\item[C-t, M-t, C-x C-t]
-- Swap characters/ \\
words/lines before and after the cursor

\item[M-l, M-u, M-c]
-- Convert word to lower case, upper case, initial capital

\item[C-\_]
-- Undo (a sequence of) changes
\end{description}
\end{slide}

\begin{slide}{}
Search
\begin{description}
\item[C-s]
(isearch-forward)
\item[C-r]
(isearch-backward)
\end{description}
Search happens as you type the string

\begin{description}
\item[DEL]
Return to last position matching what's left
\item[ESC]
Stop search, stay at found string
\item[C-g]
Quit and return to start of search
\item[C-w]
Add rest of found word to search string
\item[C-q]
Search for control char
\end{description}
\end{slide}

\begin{slide}{}
Search

Search string is remembered
\begin{description}
\item[C-s C-s] searches again

\item[M-C-s] (isearch-forward-regex)
\\
Search for a {\em regular expression}
\end{description}

Replace
\begin{description}
\item[M-\%]
(query-replace)
Type {\tt y} or {\tt n} for \\
each occurrence of $FROM$ string
\item[M-x query-replace-regexp]
Search for \\
regular expression to replace
\end{description}
\end{slide}

\begin{slide}{}
The Mark and the Region
\begin{description}
\item[C-@, C-SPC]
(set-mark-command) set \\
{\em mark} at current position
\end{description}
Text between mark and point is {\em the region}

\begin{description}
\item[C-w]
(kill-region) kills text between point and mark ("cut")
\item[C-y]
(yank) Insert last killed text at point \\
("paste")
\item[M-g]
(fill-region) join/split short/long lines
\end{description}
\end{slide}

\begin{slide}{}
Spelling correction
\begin{description}
\item[M-\$]
(spell-word) Correct spelling of word \\
before point
\item[M-x spell-buffer]
Correct spelling of each \\
word in the buffer
\item[M-/]
(dabbrev-expand) search buffer for an expansion of the abbreviation
before point
\end{description}
\end{slide}

\begin{slide}{}
Files and buffers
\begin{description}
\item[C-x C-f]
(find-file) {\em Visit} a file in its own
buffer.  Set default directory for completion to file's directory.
\item[C-x C-s]
(save-buffer) Save the current buffer in the file it is visiting.
\item[M-x revert-buffer]
Re-read file from disc

\item[C-x b $BUFFER$]
(switch-to-buffer) Select or create a buffer named $BUFFER$
\item[C-x k]
(kill-buffer) Kill one buffer
\item[C-x C-b]
(list-buffers)
\end{description}
\end{slide}

\begin{slide}{}
Dired mode
\vspace{3cm}

C-x C-f (find-file) on a directory shows output of
\ {\tt ls -l} \ in a buffer.

Provides commands to visit, delete, copy, \\
rename directory entries.
\end{slide}

\begin{slide}{}
Windows

You can have multiple windows in one emacs screen.  Each window has
its own
\begin{itemize}
\item buffer
\item point
\item mode line
\item mode
\item local variables (eg. {\tt fill-column})
\end{itemize}
One window is selected (has the cursor)
\end{slide}

\begin{slide}{}
Window commands

\vspace{3cm}

\begin{description}
\item[C-x 2]
(split-window-vertically) Split the \\
selected window into two windows, \\
one above the other
\item[C-x o]
(other-window) \\
Select the next window
\item[C-x 0] (kill-window) \\
Get rid of the selected window
\end{description}
\end{slide}

\begin{slide}{}
Major modes

{\em Major} modes are mutually exclusive.  The \\
current major mode
appears in () in the mode-line.  Some keys are redefined for each
mode.  Eg.
\begin{description}
\item Lisp mode -- bracket matching
\item C mode -- understands C syntax
\item Mail mode -- read and send mail
\item GNUS modes -- read and post news
\item Shell mode -- execute shell commands
\end{description}
\end{slide}

\begin{slide}{}
Minor modes

\vspace{3cm}

{\em Minor} modes can be combined
\begin{description}
\item auto-fill-mode -- Insert newline when you type a SPC beyond {\tt
fill-column}
\item abbrev-mode -- Expand abbreviations when you type a SPC after
one
\end{description}
\end{slide}

\begin{slide}{}
Editing programs

\begin{description}
\item[M-.]
(find-tag)
\item[M-,]
(tags-loop-continue) \\
Visit file and show function definition. \\
Uses pre-compiled TAGS file.

\item[M-x compile] and
\item[M-x grep]
Run a Unix command \\
asynchronously.  Save output in a buffer.
\item[C-x \`{}]
(next-error) Visit the cause of the \\
next error message
\end{description}
\end{slide}

\begin{slide}{}
The Init File, .emacs

Contains Lisp commands to execute \\
on start-up.  Eg.
\tt
\begin{verbatim}
(setq fill-column 60)
(display-time)
(setq TeX-dvi-print-command "xdvi ")
(autoload 'ispell-word "ispell" "" t)
(setq text-mode-hook
      (function (lambda ()
                 (auto-fill-mode 1))))
(setq c-mode-hook
      (function (lambda ()
           (setq comment-column 40))))
(define-key esc-map "[195z" 'undo)
(setq search-exit-char 0)
\end{verbatim}
\end{slide}

\begin{slide}{}
Defining commands

A new command:
\begin{verbatim}
(defun                  ;define function
  kill-whole-line       ;its name
  (n)                   ;its arguments
"Kill line point is on" ;documentation
;begining of body
  (interactive "*p")    ;how to interpret args
  (beginning-of-line)   ;move to start of line
  (kill-line n))        ;kill n whole lines
\end{verbatim}

Execute with {\tt M-x kill-whole-line} \\
or bind to a key:

{\tt\begin{verbatim}
(define-key esc-map "k"
            'kill-whole-line)
\end{verbatim}}

Note ' to quote command name
\end{slide}

\begin{slide}{}
Defining commands

{\tt interactive} declares that a function can be executed as
an interactive command (via M-x or a key binding)

It also says what arguments are passed:

\begin{tabular}{ll}
\tt (interactive) & no arguments \\
\tt (interactive "p") & prefix argument \\
                      & converted to a number \\
\tt (interactive "f") & filename read \\
                      & from minibuffer \\
\tt (interactive "r") & point and mark as \\
                      & numbers (the region)
\end{tabular}

See {\tt /usr/local/emacs/lisp/*.el} for examples
\end{slide}

\begin{slide}{}
Some useful functions

{\tt (message "It works!")(sit-for 1)} \\
Print a debugging message

{\tt (buffer-substring beg end)} \\
Return contents of buffer between \\
two positions

{\tt (re-search-forward "e..c[sh]")} \\
Search buffer for regular expression match

{\tt (insert "your card please")} \\
Insert some text at point

{\tt (y-or-n-p "Reply to Cc:\ recipients?\ ")} \\
Ask a yes/no question
\end{slide}

\begin{slide}{}
Further information

Manual page: {\tt man emacs} -- start-up and \\
X-windows options

Newsgroup: {\tt gnu.emacs.help} -- general \\
queries about use and programming

Lisp Code Direcory (LCD)

Database of 500+ Emacs elisp programs

FTP from {\tt tut.cis.ohio-state.edu} \\
{\tt pub/gnu/emacs/elisp-archive/LCD-datafile.Z}

{\tt lispdir.el} -- an elisp package for locating elisp packages
\end{slide}

\begin{slide}{}
Sed --- {\em S}\/tream {\em ed}\/itor

Replace strings matching regular expressions

Useful for building tools and reformating data

Eg.
\begin{verbatim}
sed 's/IC/ICSTM/' cv > new_cv
\end{verbatim}

Replace all occurrences of ``IC'' with ``ICSTM''

\begin{verbatim}
sed 's/0\(1-58[0-9]\)/07\1/g'
\end{verbatim}

Replace ``01-58$d$'' with ``071-58$d$'' where $d$ is any decimal
digit
\end{slide}

\begin{slide}{}
Regular Expressions

Ordinary characters match themselves, \\
special characters have the
following meanings (unless quoted with $\backslash$ ):

\begin{description}
\item[.]
Matches any character except NEWLINE
\item[\^{}]
At start of RE matches start of line
\item[\$]
At end of RE matches end of line
\item[[abcdef]]
Matches any one of the characters {\tt a b c d e} or {\tt f}
\item[[\^{}abcdef]]
Matches any one character {\em except} {\tt a b c d e} or {\tt f}
\item[[A-Z\_{}]]
Matches any one character in the range {\tt A \ldots Z} or {\tt \_{}}
\end{description}
\end{slide}

\begin{slide}{}
Multi-character REs

REs can be joined together.  Eg.

{\tt [abc][xyz]}

matches {\tt a b} or {\tt c} followed by {\tt x y} or {\tt z}, \\
ie. {\tt ax ay az bx by bz cx cy} or {\tt cz}

A one-character RE followed by {\tt *} matches zero or more
occurrences of the one-character RE.\@  Eg.

{\tt ele.*phy\$}

matches ``electroencephalography'' \\
 or ``telegraphy''.

{\tt [A-Za-z0-9]*}

matches any alphanumeric sequence.
\end{slide}

\begin{slide}{}
Counted matches

\vspace{3cm}

$re \backslash \{ m \backslash \}$ matches $re$ $m$ times.  Eg.

$[a-z] \backslash \{22 \backslash \}$

matches any 22-letter word.

$re \backslash \{m,\backslash \}$ matches $re$ at least $m$ times and
$re \backslash \{m,n \backslash \}$ matches $re$ between $m$ and $n$
times inclusive.
\end{slide}

\begin{slide}{}
Saved matches

The string matched by a RE in $\backslash ($ $\backslash )$ is saved and can be
referred to as $\backslash n$.  Eg.

\begin{verbatim}
sed 's/0\(1-58[0-9]\)/07\1/g'
\end{verbatim}

Replace ``01-58$d$'' with ``071-58$d$''. \\
Note: ``g'' means {\em all} matches, not just first on each line.

\begin{verbatim}
sed 's/^\(.\{12\}\)\(.\{6\}\)/\2 = \1/'
\end{verbatim}

Swap round the first 12 characters and the next 6 and insert `` = ''
between them
\end{slide}

\begin{slide}{}
Other sed commands

\vspace{3cm}

Sed also has commands to insert and delete lines of text and even
execute {\em loops}.  Eg.

\begin{verbatim}
sed '
#Define a label ``brackets''
: brackets
#Replace matching < > with { }
s/<\([^<>]*\)>/{\1}/g
#Loop until no more replacements
t brackets
'
\end{verbatim}

\end{slide}

\begin{slide}{}
Awk

(Aho, Weinberger and Kernighan)

\vspace{3cm}

awk breaks each input line into {\em fields} \\
(seperated by white-space).

It is programmed with a C-like syntax \\
combined with regular expression matching.
\end{slide}

\begin{slide}{}
Print the longest line in the input

\begin{verbatim}
pr -te $* | awk '
length > max {
        max=length;
        maxline=$0
}
END {
        print maxline
}'
\end{verbatim}
\end{slide}

\begin{slide}{}
Print the names of all files containing more than 400 lines.

{\tt wc -l *}

prints

\begin{verbatim}
     544 Eliot
     781 JDR
      76 Jim
     498 Sandra
     248 Scott
     422 Steve

wc -l * | awk '$1 >= 400 { print $2 }'
\end{verbatim}

prints

\begin{verbatim}
Eliot
JDR
Sandra
Steve
\end{verbatim}
\end{slide}

\begin{slide}{}
A larger program

Reads input lines of the form

\begin{tabular}{ccccc}
\$1 & \$2 & \$3 & \$4  & ... \\
host & tty & day & time & full name
\end{tabular}

Prints time, host and full-name if $day$ or $time$ is different from
previous line with the same $host$ and $tty$.

{\tt /Login/} executes following commands only for lines containing
the string ``Login''

lastdone is an {\em associative array} indexed by strings.
\end{slide}

\begin{slide}{}
\begin{verbatim}
awk '
/Login/ { next }
{
  tty = $2 $1;
  when = $3 " " $4;
  if (when != lastdone[tty])
  {
    lastdone[tty] = when;
    printf("%s %-8s %s %s %s %s\n",
    when, $1, $5, $6, $7, $8);
  }
}'
\end{verbatim}
\end{slide}
\end{document}
